package j2735ffm;

import generated.convert_h;
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.SymbolLookup;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.charset.StandardCharsets;

import static generated.convert_h.convert_bytes;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Objects;
import lombok.extern.slf4j.Slf4j;


/**
 * Functions for interconverting J2735 (2024) MessageFrames between XER, JER, and UPER encodings
 * by calling native functions generated by asn1c.
 *
 * @author Ivan Yourshaw
 */
@Slf4j
public class MessageFrameCodec {

    public final static String PDU = "MessageFrame";

    /**
     * Output buffer size for XER and JSON.  Messages larger than this can't be produced.
     */
    public final long textBufferSize;

    /**
     * Buffer size for UPER binary messages.  Messages larger than this can't be produced.
     */
    public final long uperBufferSize;

    /**
     * Buffer size for internal representation of a MessageFrame_t struct
     */
    public final long messageFrameAllocateSize;

    public final long asnCodecCtxMaxStackSize;

    public MessageFrameCodec() {
        this(262144L, 8192L, 16384L, 30000L);
        loadLibrary();
    }

    public MessageFrameCodec(
            long textBufferSize,
            long uperBufferSize,
            long messageFrameAllocateSize,
            long asnCodecCtxMaxStackSize) {
        this.textBufferSize = textBufferSize;
        this.uperBufferSize = uperBufferSize;
        this.messageFrameAllocateSize = messageFrameAllocateSize;
        this.asnCodecCtxMaxStackSize = asnCodecCtxMaxStackSize;
        log.info("MessageFrameCodec initialized with textBufferSize: {}, uperBufferSize: {}, messageFrameAllocateSize: {}, asnCodecCtxMaxStackSize: {}",
                textBufferSize, uperBufferSize, messageFrameAllocateSize, asnCodecCtxMaxStackSize);
        loadLibrary();
    }

    public MessageFrameCodec(
        long textBufferSize, long uperBufferSize, URI libraryURI
    ) {
        this(textBufferSize, uperBufferSize, 16384L, 30000L);
        loadLibrary(libraryURI);
    }

    /**
     * Default loader doesn't work with Spring Boot
     */
    private void loadLibrary() {
        ClassLoader classLoader = MessageFrameCodec.class.getClassLoader();
        // Load the library into the global arena
        if (isWindows()) {
            log.warn("Windows: no library available");
            return;
        }
        URL libraryUrl = classLoader.getResource("j2735ffm/libasnapplication.so");
        if (libraryUrl == null) {
            throw new RuntimeException("libasnapplication.so resource not found");
        } else {
            log.info("Found library: {}", libraryUrl);
        }
        try {
            URI libUri = libraryUrl.toURI();
            loadLibrary(libUri);
        } catch (URISyntaxException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * load library with given class loader.  Needed by Spring Boot
     * @param libUri The URI of the library resource
     */
    private void loadLibrary(URI libUri) {
        // Load the library into a garbage-collected arena
        Arena global = Arena.ofAuto();
        if (isWindows()) {
            log.warn("Windows: no library available");
        } else {
            Path pathToLibrary = Paths.get(libUri);
            SymbolLookup lookup = SymbolLookup.libraryLookup(pathToLibrary, global);
            log.info("Loaded library: {}", pathToLibrary);
            var symbol = lookup.find("convert_bytes");
            if (symbol.isPresent()) {
                log.info("found symbol convert_bytes: {}", symbol);
            } else {
                throw new RuntimeException("symbol 'convert_bytes' not found in the library");
            }
            convert_h.SYMBOL_LOOKUP = lookup;
        }
    }

    private boolean isWindows() {
        return System.getProperty("os.name").toLowerCase().contains("win");
    }


    public byte[] xerToUper(String xer) {
        log.debug("xerToUper: {}", xer);
        try (var arena = Arena.ofConfined()) {
            MemorySegment inputBuffer = arena.allocate(textBufferSize);
            MemorySegment outputBuffer = arena.allocate(uperBufferSize);
            return convert(arena, xer.getBytes(StandardCharsets.UTF_8), "xer",
                "uper", inputBuffer, outputBuffer, uperBufferSize);
        } catch (Exception e) {
            log.error(e.getMessage(), e);
            throw new RuntimeException(e);
        }
    }


    public String uperToXer(byte[] uper) {
        log.trace("Received {} bytes", uper.length);
        try (var arena = Arena.ofConfined()) {
            MemorySegment inputBuffer = arena.allocate(uperBufferSize);
            MemorySegment outputBuffer = arena.allocate(textBufferSize);
            byte[] xerBytes = convert(arena, uper, "uper", "xer",
                inputBuffer, outputBuffer, textBufferSize);
            return new String(xerBytes, StandardCharsets.UTF_8);
        }
    }



    private byte[] convert(Arena arena, final byte[] bytes,
        final String fromEncoding, final String toEncoding, MemorySegment inputBuffer,
        MemorySegment outputBuffer, long outputBufferSize) {
        log.debug("convert: {} {}", fromEncoding, toEncoding);
        byte[] outputArray = null;

        MemorySegment heapBytes = MemorySegment.ofArray(bytes);
        inputBuffer.copyFrom(heapBytes);
        MemorySegment pduName = arena.allocateFrom(PDU, StandardCharsets.UTF_8);
        MemorySegment fromEncodingSeg = arena.allocateFrom(fromEncoding,
            StandardCharsets.UTF_8);
        MemorySegment toEncodingSeg = arena.allocateFrom(toEncoding, StandardCharsets.UTF_8);
        log.debug("calling convert_bytes");
        long numOut = 0;
        try {
            numOut = convert_bytes(pduName, fromEncodingSeg, toEncodingSeg, inputBuffer,
                bytes.length, outputBuffer, outputBufferSize);
        } catch (Throwable ex) {
            log.info("error converting");
            log.error(ex.getMessage(), ex);
        }
        log.debug("numOut: {}", numOut);
        outputArray = new byte[(int) numOut];
        MemorySegment heapOutput = MemorySegment.ofArray(outputArray);
        MemorySegment.copy(outputBuffer, 0, heapOutput, 0, numOut);

        return outputArray;
    }

}
