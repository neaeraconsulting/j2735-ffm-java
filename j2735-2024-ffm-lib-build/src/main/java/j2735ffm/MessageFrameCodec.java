package j2735ffm;

import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.nio.charset.StandardCharsets;

import static generated.convert_h.convert_bytes;

import lombok.extern.slf4j.Slf4j;


/**
 * Functions for interconverting J2735 (2024) MessageFrames between XER, JER, and UPER encodings
 * by calling native functions generated by asn1c.
 *
 * @author Ivan Yourshaw
 */
@Slf4j
public class MessageFrameCodec {

    public final static String PDU = "MessageFrame";

    /**
     * Output buffer size for XER and JSON.  Messages larger than this can't be produced.
     */
    public final long textBufferSize;

    /**
     * Buffer size for UPER binary messages.  Messages larger than this can't be produced.
     */
    public final long uperBufferSize;

    /**
     * Buffer size for internal representation of a MessageFrame_t struct
     */
    public final long messageFrameAllocateSize;

    public final long asnCodecCtxMaxStackSize;

    public MessageFrameCodec() {
        this.textBufferSize = 262144L;
        this.uperBufferSize = 8192L;
        this.messageFrameAllocateSize = 16384L;
        this.asnCodecCtxMaxStackSize = 30000L;
        log.info("MessageFrameCodec initialized with defaults: textBufferSize: {}, uperBufferSize: {}, messageFrameAllocateSize: {}, asnCodecCtxMaxStackSize: {}",
                textBufferSize, uperBufferSize, messageFrameAllocateSize, asnCodecCtxMaxStackSize);
    }

    public MessageFrameCodec(
            long textBufferSize,
            long uperBufferSize,
            long messageFrameAllocateSize,
            long asnCodecCtxMaxStackSize) {
        this.textBufferSize = textBufferSize;
        this.uperBufferSize = uperBufferSize;
        this.messageFrameAllocateSize = messageFrameAllocateSize;
        this.asnCodecCtxMaxStackSize = asnCodecCtxMaxStackSize;
        log.info("MessageFrameCodec initialized with textBufferSize: {}, uperBufferSize: {}, messageFrameAllocateSize: {}, asnCodecCtxMaxStackSize: {}",
                textBufferSize, uperBufferSize, messageFrameAllocateSize, asnCodecCtxMaxStackSize);
    }


    public byte[] xerToUper(String xer) {
        try (var arena = Arena.ofConfined()) {
            MemorySegment inputBuffer = arena.allocate(textBufferSize);
            MemorySegment outputBuffer = arena.allocate(uperBufferSize);
            return convert(arena, xer.getBytes(StandardCharsets.UTF_8), "xer",
                "uper", inputBuffer, outputBuffer, uperBufferSize);
        }
    }


    public String uperToXer(byte[] uper) {
        log.trace("Received {} bytes", uper.length);
        try (var arena = Arena.ofConfined()) {
            MemorySegment inputBuffer = arena.allocate(uperBufferSize);
            MemorySegment outputBuffer = arena.allocate(textBufferSize);
            byte[] xerBytes = convert(arena, uper, "uper", "xer",
                inputBuffer, outputBuffer, textBufferSize);
            return new String(xerBytes, StandardCharsets.UTF_8);
        }
    }



    private byte[] convert(Arena arena, final byte[] bytes,
        final String fromEncoding, final String toEncoding, MemorySegment inputBuffer,
        MemorySegment outputBuffer, long outputBufferSize) {

        MemorySegment heapBytes = MemorySegment.ofArray(bytes);
        inputBuffer.copyFrom(heapBytes);
        MemorySegment pduName = arena.allocateFrom(PDU, StandardCharsets.UTF_8);
        MemorySegment fromEncodingSeg = arena.allocateFrom(fromEncoding, StandardCharsets.UTF_8);
        MemorySegment toEncodingSeg = arena.allocateFrom(toEncoding, StandardCharsets.UTF_8);

        long numOut = convert_bytes(pduName, fromEncodingSeg, toEncodingSeg, inputBuffer, bytes.length, outputBuffer, outputBufferSize);

        byte[] outputArray = new byte[(int) numOut];
        MemorySegment heapOutput = MemorySegment.ofArray(outputArray);
        MemorySegment.copy(outputBuffer, 0, heapOutput, 0, numOut);
        return outputArray;
    }

}
