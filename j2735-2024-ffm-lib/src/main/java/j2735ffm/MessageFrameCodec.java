package j2735ffm;

import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.ValueLayout;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.HexFormat;

import static j2735_2024_MessageFrame.MessageFrame_h.*;
import j2735_2024_MessageFrame.*;
import lombok.extern.slf4j.Slf4j;


/**
 * Functions for interconverting J2735 (2024) MessageFrames between XER, JER, and UPER encodings
 * by calling native functions generated by asn1c.
 *
 * @author Ivan Yourshaw
 */
@Slf4j
public class MessageFrameCodec {

    /**
     * Output buffer size for XER and JSON.  Messages larger than this can't be produced.
     */
    public final long textBufferSize;

    /**
     * Buffer size for UPER binary messages.  Messages larger than this can't be produced.
     */
    public final long uperBufferSize;

    /**
     * Buffer size for internal representation of a MessageFrame_t struct
     */
    public final long messageFrameAllocateSize;

    public final long asnCodecCtxMaxStackSize;

    public MessageFrameCodec() {
        this.textBufferSize = 262144L;
        this.uperBufferSize = 8192L;
        this.messageFrameAllocateSize = 16384L;
        this.asnCodecCtxMaxStackSize = 30000L;
        log.info("MessageFrameCodec initialized with defaults: textBufferSize: {}, uperBufferSize: {}, messageFrameAllocateSize: {}, asnCodecCtxMaxStackSize: {}",
                textBufferSize, uperBufferSize, messageFrameAllocateSize, asnCodecCtxMaxStackSize);
    }

    public MessageFrameCodec(
            long textBufferSize,
            long uperBufferSize,
            long messageFrameAllocateSize,
            long asnCodecCtxMaxStackSize) {
        this.textBufferSize = textBufferSize;
        this.uperBufferSize = uperBufferSize;
        this.messageFrameAllocateSize = messageFrameAllocateSize;
        this.asnCodecCtxMaxStackSize = asnCodecCtxMaxStackSize;
        log.info("MessageFrameCodec initialized with textBufferSize: {}, uperBufferSize: {}, messageFrameAllocateSize: {}, asnCodecCtxMaxStackSize: {}",
                textBufferSize, uperBufferSize, messageFrameAllocateSize, asnCodecCtxMaxStackSize);
    }


    public byte[] xerToUper(String xer) {
        try (var arena = Arena.ofConfined()) {
            MemorySegment messageFrame = arena.allocate(messageFrameAllocateSize);
            xerToMessageFrame(arena, xer, messageFrame);
            MemorySegment outputBuffer = arena.allocate(uperBufferSize);
            return messageFrameToUper(arena, messageFrame, uperBufferSize, outputBuffer);
        }
    }

    public byte[] jerToUper(String jer) {
        try (var arena = Arena.ofConfined()) {
            MemorySegment messageFrame = arena.allocate(messageFrameAllocateSize);
            jerToMessageFrame(arena, jer, messageFrame);
            MemorySegment outputBuffer = arena.allocate(uperBufferSize);
            return messageFrameToUper(arena, messageFrame, uperBufferSize, outputBuffer);
        }
    }

    public String uperToXer(byte[] uper) {
        log.trace("Received {} bytes", uper.length);
        try (var arena = Arena.ofConfined()) {
            MemorySegment messageFrame = arena.allocate(messageFrameAllocateSize);
            MemorySegment outputBuffer = arena.allocate(textBufferSize);
            return uperToXer(uper, arena, messageFrame, textBufferSize, outputBuffer);
        }
    }

    public String uperToXer(byte[] uper, Arena arena, MemorySegment messageFrame, long bufferSize, MemorySegment outputBuffer) {
        uperToMessageFrame(arena, uper, messageFrame);
        return messageFrameToXer(arena, messageFrame, bufferSize, outputBuffer);
    }

    public String uperToJer(byte[] uper) {
        log.trace("Received {} bytes", uper.length);
        try (var arena = Arena.ofConfined()) {
            MemorySegment messageFrame = arena.allocate(messageFrameAllocateSize);
            uperToMessageFrame(arena, uper, messageFrame);
            MemorySegment outputBuffer = arena.allocate(textBufferSize);
            return messageFrameToJer(arena, messageFrame, textBufferSize, outputBuffer);
        }
    }

    public String xerToJer(String xer) {
        try (var arena = Arena.ofConfined()) {
            MemorySegment messageFrame = arena.allocate(messageFrameAllocateSize);
            xerToMessageFrame(arena, xer, messageFrame);
            MemorySegment outputBuffer = arena.allocate(textBufferSize);
            return messageFrameToJer(arena, messageFrame, textBufferSize, outputBuffer);
        }
    }

    public String jerToXer(String jer) {
        try (var arena = Arena.ofConfined()) {
            MemorySegment messageFrame = arena.allocate(messageFrameAllocateSize);
            jerToMessageFrame(arena, jer, messageFrame);
            MemorySegment outputBuffer = arena.allocate(textBufferSize);
            return messageFrameToXer(arena, messageFrame, textBufferSize, outputBuffer);
        }
    }

    private void printMessageFrame(Arena arena, MemorySegment messageFrame) {
        log.trace("Printing message frame");
        int printResult = asn_fprint(stdout(), asn_DEF_MessageFrame(), messageFrame);
        log.trace("Printed message frame to stdout, result: " + printResult);
    }

    private void decodeToMessageFrame(Arena arena, final byte[] bytes, final int asnTransferSyntax,
                                               MemorySegment messageFrame) {
        log.trace("decodeToMessageFrame, num bytes: {}, transfer syntax: {}", bytes.length,
                asnTransferSyntax);

        MemorySegment heapBytes = MemorySegment.ofArray(bytes);
        MemorySegment optCodecParameters = optCodecParameters(arena);

        // The result Message Frame
        //
        // Allocate the memory to receive a MessageFrame_t structure, because passing a pointer to 0 and having the
        // decoder create the structure dynamically, as the C API docs recommend, would create a memory leak, because
        // since we don't know the size of the created struct we can't reinterpret and free the memory using
        // malloc/free, nor do we have access to the ASN_STRUCT_FREE macro from here.
        //
        // TODO Create a C header and function to expose ASN_STRUCT_FREE to FFM
        // Also see https://docs.oracle.com/en/java/javase/23/core/foreign-functions-that-return-pointers.html
        //
        // Meanwhile, instead, pre-allocate a buffer large enough to handle the expected size of the returned data
        // structure, managed by the memory arena, so it will be freed at the end of the try-with-resources.
        //
        // UPER decoding fails using MessageFrame_t.allocate(),  probably because the MessageFrame value is an ASN.1
        // open type whose size can't be determined just from the top level struct, so preallocate a fixed buffer size
        // to make sure it is large enough.
        //MemorySegment messageFrame = arena.allocate(messageFrameAllocateSize);

        // Pointer to result MessageFrame
        MemorySegment structurePtr = arena.allocate(ValueLayout.ADDRESS.byteSize());

        // We  assume the address is a Java long.  But if the FFM code were recompiled on a platform other than x64,
        // this wouldn't necessarily be true.
        assert ValueLayout.ADDRESS.byteSize() == ValueLayout.JAVA_LONG.byteSize();

        // Point to the preallocated MessageFrame buffer
        structurePtr.set(ValueLayout.JAVA_LONG, 0, messageFrame.address());

        // Pointer to 0 that we are not using for now
        //structurePtr.set(ValueLayout.JAVA_LONG, 0, 0L);

        MemorySegment buffer = arena.allocate(bytes.length);
        buffer.copyFrom(heapBytes);
        MemorySegment er;

        er = asn_decode(arena, optCodecParameters, asnTransferSyntax, asn_DEF_MessageFrame(), structurePtr,
                buffer, bytes.length);

        long retCode = asn_dec_rval_t.code(er);
        long consumed = asn_dec_rval_t.consumed(er);
        String rcEnum = switch ((int)retCode) {
            case 0 -> "RC_OK";
            case 1 -> "RC_WMORE";
            case 2 -> "RC_FAIL";
            default -> "Unknown return code";
        };

        var msg = String.format("asn_decode return code: %s %s, consumed: %s", retCode, rcEnum, consumed);
        long messageFramePointer = structurePtr.get(ValueLayout.JAVA_LONG, 0);
        log.trace("messageFrame pointer: {}", messageFramePointer);

        // This is how to get the externally allocated MessageFrame.  It works, but don't do it without
        // reinterpreting and freeing.
        //MemorySegment messageFrame = MemorySegment.ofAddress(structurePtr.get(ValueLayout.JAVA_LONG, 0));

        if (retCode == 0) {
            log.trace(msg);
        } else {
            // Print partially decoded data
            printMessageFrame(arena, messageFrame);
            throw new RuntimeException("decode encountered error or RC_WMORE condition: " + msg);
        }

        //return messageFrame;
    }

    private void xerToMessageFrame(Arena arena, String xer, MemorySegment messageFrame) {
        log.trace("xerToMessageFrame");
        byte[] xmlBytes = xer.getBytes(StandardCharsets.UTF_8);
        decodeToMessageFrame(arena, xmlBytes, ATS_CANONICAL_XER(), messageFrame);
    }

    private void jerToMessageFrame(Arena arena, String jer, MemorySegment messageFrame) {
        log.trace("jerToMessageFrame");
        byte[] jsonBytes = jer.getBytes(StandardCharsets.UTF_8);
        decodeToMessageFrame(arena, jsonBytes, ATS_JER(), messageFrame);
    }

    private void uperToMessageFrame(Arena arena, byte[] uper, MemorySegment messageFrame) {
        log.trace("uperToMessageFrame");
        decodeToMessageFrame(arena, uper, ATS_UNALIGNED_BASIC_PER(), messageFrame);
    }

    private byte[] encodeFromMessageFrame(Arena arena, MemorySegment messageFrame, final int asnTransferSyntax,
                                          final long bufferSize, MemorySegment outputBuffer) {
        log.trace("encodeFromMessageFrame, transferSyntax: {}, bufferSize: {}", asnTransferSyntax, bufferSize);
        MemorySegment optCodecParameters = optCodecParameters(arena);
        MemorySegment erEnc = asn_encode_to_buffer(arena, optCodecParameters, asnTransferSyntax,
                asn_DEF_MessageFrame(), messageFrame, outputBuffer, bufferSize);
        long encoded = asn_enc_rval_t.encoded(erEnc);
        if (encoded > -1) {
            log.trace("asn_encode_to_buffer succeeded. Encoded {} bytes", encoded);
            byte[] outputArray = new byte[(int) encoded];
            MemorySegment heapOutput = MemorySegment.ofArray(outputArray);
            MemorySegment.copy(outputBuffer, 0, heapOutput, 0, encoded);
            return outputArray;
        } else {
            log.trace("Error in asn_encode_to_buffer");
            throw new RuntimeException("Error calling asn_encode_to_buffer");
            // Check the error info
            // fprintf(stderr, ”Cannot encode %s: %s\n”, er.failed_type >name, strerror(errno))
            // Need c function to expose errno macro
        }
    }

    private byte[] messageFrameToUper(Arena arena, MemorySegment messageFrame, long bufferSize, MemorySegment outputBuffer) {
        log.trace("messageFrameToUper");
        return encodeFromMessageFrame(arena, messageFrame, ATS_UNALIGNED_BASIC_PER(), bufferSize, outputBuffer);
    }

    private String messageFrameToXer(Arena arena, MemorySegment messageFrame, long bufferSize, MemorySegment outputBuffer) {
        log.trace("messageFrameToXer");
        byte[] bytes = encodeFromMessageFrame(arena, messageFrame, ATS_CANONICAL_XER(), bufferSize, outputBuffer);
        return new String(bytes, StandardCharsets.UTF_8);
    }

    private String messageFrameToJer(Arena arena, MemorySegment messageFrame, long bufferSize, MemorySegment outputBuffer) {
        log.trace("messageFrameToJer");
        byte[] bytes = encodeFromMessageFrame(arena, messageFrame, ATS_JER(), bufferSize, outputBuffer);
        return new String(bytes, StandardCharsets.UTF_8);
    }

    private MemorySegment optCodecParameters(Arena arena) {
        MemorySegment optCodecParameters = asn_codec_ctx_t.allocate(arena);
        asn_codec_ctx_t.max_stack_size(optCodecParameters, asnCodecCtxMaxStackSize);
        return optCodecParameters;
    }


}
