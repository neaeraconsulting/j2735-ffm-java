/*
   Copyright 2025 Neaera Consulting LLC

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

package j2735ffm;

import generated.convert_h;
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.SymbolLookup;
import java.nio.charset.StandardCharsets;

import static generated.convert_h.convert_bytes;

import java.nio.file.Path;
import java.nio.file.Paths;
import lombok.extern.slf4j.Slf4j;


/**
 * Functions for interconverting J2735 (2024) MessageFrames between XER, and UPER encodings
 * by calling native functions generated by asn1c.
 *
 * @author Ivan Yourshaw
 */
@Slf4j
public class MessageFrameCodec {

    public final static String MESSAGE_FRAME_PDU = "MessageFrame";

    /**
     * Output buffer size for XER and JSON.  Messages larger than this can't be produced.
     */
    public final long textBufferSize;

    /**
     * Buffer size for UPER binary messages.  Messages larger than this can't be produced.
     */
    public final long uperBufferSize;

    /**
     * Buffer size for error messages returned from the native library.
     */
    public final long errorBufferSize;

    private final static Path DEFAULT_LIBRARY_PATH = Paths.get("/usr/lib/libasnapplication.so");

    @Deprecated
    public MessageFrameCodec(
            long textBufferSize,
            long uperBufferSize,
            @Deprecated long messageFrameAllocateSize,
            @Deprecated long asnCodecCtxMaxStackSize) {
        this(textBufferSize, uperBufferSize, 256L, DEFAULT_LIBRARY_PATH);
    }

    /**
     * Constructor.  Configures the library and loads the underlying native library
     * @param textBufferSize - Size of the input or output buffer for text encodings (XER)
     * @param uperBufferSize - Size of the input or output buffer for UPER binary encoding.
     * @param libraryPath - Absolute or relative path to the native library, e.g. "/usr/lib/libasnapplication.so"
     */
    public MessageFrameCodec(long textBufferSize, long uperBufferSize, long errorBufferSize,
            Path libraryPath) {
        this.textBufferSize = textBufferSize;
        this.uperBufferSize = uperBufferSize;
        this.errorBufferSize = errorBufferSize;
        loadLibrary(libraryPath);
        log.info("MessageFrameCodec initialized with textBufferSize: {}, uperBufferSize: {}, libraryPath: {}",
            textBufferSize, uperBufferSize, libraryPath);
    }



    /**
     * load library with given class loader.
     * @param libraryPath The URI of the library resource
     */
    private void loadLibrary(Path libraryPath) {
        // Load the library into a garbage-collected arena
        Arena arena = Arena.ofAuto();
        SymbolLookup lookup = SymbolLookup.libraryLookup(libraryPath, arena);
        log.info("Loaded library: {}", libraryPath);
        var symbol = lookup.find("convert_bytes");
        if (symbol.isPresent()) {
            log.info("found symbol convert_bytes: {}", symbol);
        } else {
            throw new RuntimeException("symbol 'convert_bytes' not found in the library");
        }
        // Note: Assign the lookup to a static field in the generated code.
        // This will prevent the library from being garbage collected until
        // the class loader that loaded the "convert_h" class is itself garbage collected.
        // Normally that would happen when the JVM exits, but could happen sooner if this library is
        // loaded dynamically by a custom class loader or is used in the context of OSGI or
        // something. We do this instead of using the global arena to prevent memory leaks
        // in case of that unlikely, but possible, scenario.
        convert_h.SYMBOL_LOOKUP = lookup;
    }

    /**
     * General purpose conversion function that can convert any PDU to or from
     * any encoding.
     * @param inputBytes Input byte array: XER or UPER binary
     * @param pdu The name of the PDU, e.g., "MessageFrame", "MessageFrame", "VehicleEventFlags", etc.
     * @param fromEncoding Input encoding, may be "xer" or "uper"
     * @param toEncoding Output encoding, may be "xer" or "uper"
     * @return The encoded message as bytes or UTF-8 string
     */
    public byte[] convertGeneral(byte[] inputBytes, String pdu, String fromEncoding, String toEncoding) {
        log.debug("convertGeneral PDU: {}, {} -> {}", pdu, fromEncoding, toEncoding);
        final long inputBufferSize = "uper".equals(fromEncoding) ? uperBufferSize : textBufferSize;
        if (inputBytes.length > inputBufferSize) {
            String errMsg = String.format("Input message too large: %d > %d", inputBytes.length, inputBufferSize);
            log.error(errMsg);
            throw new IllegalArgumentException(errMsg);
        }
        final long outputBufferSize = "uper".equals(toEncoding) ? uperBufferSize : textBufferSize;
        try (var arena = Arena.ofConfined()) {
            MemorySegment inputBuffer = arena.allocate(inputBufferSize);
            MemorySegment outputBuffer = arena.allocate(outputBufferSize);
            MemorySegment errorBuffer = arena.allocate(errorBufferSize);
            return convert(arena, inputBytes, fromEncoding,
                toEncoding, inputBuffer, outputBuffer, outputBufferSize, errorBuffer,
                errorBufferSize, pdu);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * Convert an XER encoded MessageFrame to UPER
     * @param xer The XER encoded MessageFrame
     * @return Byte array with the UPER encoding
     */
    public byte[] xerToUper(String xer) {
        log.debug("xerToUper: {}", xer);
        if (xer.length() > textBufferSize) {
            String errMsg = String.format("Input XER message too large: %d > %d", xer.length(), textBufferSize);
            log.error(errMsg);
            throw new IllegalArgumentException(errMsg);
        }
        try (var arena = Arena.ofConfined()) {
            MemorySegment inputBuffer = arena.allocate(textBufferSize);
            MemorySegment outputBuffer = arena.allocate(uperBufferSize);
            MemorySegment errorBuffer = arena.allocate(errorBufferSize);
            return convert(arena, xer.getBytes(StandardCharsets.UTF_8), "xer",
                "uper", inputBuffer, outputBuffer, uperBufferSize, errorBuffer,
                errorBufferSize, MESSAGE_FRAME_PDU);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Convert an UPER encoded MessageFrame to XER
     * @param uper The UPER encoded MessageFrame
     * @return XER encoded result
     */
    public String uperToXer(byte[] uper) {
        log.trace("Received {} bytes", uper.length);
        if (uper.length > uperBufferSize) {
            String errMsg = String.format("Input UPER message too large: %d > %d", uper.length, uperBufferSize);
            log.error(errMsg);
            throw new IllegalArgumentException(errMsg);
        }
        try (var arena = Arena.ofConfined()) {
            MemorySegment inputBuffer = arena.allocate(uperBufferSize);
            MemorySegment outputBuffer = arena.allocate(textBufferSize);
            MemorySegment errorBuffer = arena.allocate(errorBufferSize);
            byte[] xerBytes = convert(arena, uper, "uper", "xer",
                inputBuffer, outputBuffer, textBufferSize, errorBuffer, errorBufferSize,
                MESSAGE_FRAME_PDU);
            return new String(xerBytes, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    private byte[] convert(Arena arena, final byte[] bytes,
            final String fromEncoding, final String toEncoding, MemorySegment inputBuffer,
            MemorySegment outputBuffer, long outputBufferSize, MemorySegment errorBuffer,
            long errorBufferSize, final String pdu)
            throws ConvertException{
        log.debug("convert: {} {}", fromEncoding, toEncoding);
        byte[] outputArray = null;

        MemorySegment heapBytes = MemorySegment.ofArray(bytes);
        inputBuffer.copyFrom(heapBytes);
        MemorySegment pduName = arena.allocateFrom(pdu, StandardCharsets.UTF_8);
        MemorySegment fromEncodingSeg = arena.allocateFrom(fromEncoding,
            StandardCharsets.UTF_8);
        MemorySegment toEncodingSeg = arena.allocateFrom(toEncoding, StandardCharsets.UTF_8);
        log.debug("calling convert_bytes");
        long numOut = 0;
        try {
            numOut = convert_bytes(pduName, fromEncodingSeg, toEncodingSeg, inputBuffer,
                bytes.length, outputBuffer, outputBufferSize, errorBuffer, errorBufferSize);
        } catch (Throwable ex) {
            log.info("error converting");
            throw ex;
        }
        log.debug("numOut: {}", numOut);
        if (numOut < 0) {
            // Error was returned
            String error = errorBuffer.getString(0);
            log.error(error);
            throw new ConvertException(error);
        }
        outputArray = new byte[(int) numOut];
        MemorySegment heapOutput = MemorySegment.ofArray(outputArray);
        MemorySegment.copy(outputBuffer, 0, heapOutput, 0, numOut);

        return outputArray;
    }

}
