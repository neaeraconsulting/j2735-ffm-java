/*
   Copyright 2025 Neaera Consulting LLC

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

package j2735ffm;

import generated.convert_h;
import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.SymbolLookup;
import java.nio.charset.StandardCharsets;

import static generated.convert_h.convert_bytes;

import java.nio.file.Path;
import java.nio.file.Paths;
import lombok.extern.slf4j.Slf4j;


/**
 * Functions for interconverting J2735 (2024) MessageFrames between XER, JER, and UPER encodings
 * by calling native functions generated by asn1c.
 *
 * @author Ivan Yourshaw
 */
@Slf4j
public class MessageFrameCodec {

    public final static String PDU = "MessageFrame";

    /**
     * Output buffer size for XER and JSON.  Messages larger than this can't be produced.
     */
    public final long textBufferSize;

    /**
     * Buffer size for UPER binary messages.  Messages larger than this can't be produced.
     */
    public final long uperBufferSize;

    private final static Path DEFAULT_LIBRARY_PATH = Paths.get("/usr/lib/libasnapplication.so");

    @Deprecated
    public MessageFrameCodec(
            long textBufferSize,
            long uperBufferSize,
            @Deprecated long messageFrameAllocateSize,
            @Deprecated long asnCodecCtxMaxStackSize) {
        this(textBufferSize, uperBufferSize, DEFAULT_LIBRARY_PATH);
    }

    /**
     * Constructor.  Configures the library and loads the underlying native library
     * @param textBufferSize - Size of the input or output buffer for text encodings (XER)
     * @param uperBufferSize - Size of the input or output buffer for UPER binary encoding.
     * @param libraryPath - Absolute or relative path to the native library, e.g. "/usr/lib/libasnapplication.so"
     */
    public MessageFrameCodec(long textBufferSize, long uperBufferSize, Path libraryPath) {
        this.textBufferSize = textBufferSize;
        this.uperBufferSize = uperBufferSize;
        loadLibrary(libraryPath);
        log.info("MessageFrameCodec initialized with textBufferSize: {}, uperBufferSize: {}, libraryPath: {}",
            textBufferSize, uperBufferSize, libraryPath);
    }



    /**
     * load library with given class loader.
     * @param libraryPath The URI of the library resource
     */
    private void loadLibrary(Path libraryPath) {
        // Load the library into a garbage-collected arena
        Arena arena = Arena.ofAuto();
        SymbolLookup lookup = SymbolLookup.libraryLookup(libraryPath, arena);
        log.info("Loaded library: {}", libraryPath);
        var symbol = lookup.find("convert_bytes");
        if (symbol.isPresent()) {
            log.info("found symbol convert_bytes: {}", symbol);
        } else {
            throw new RuntimeException("symbol 'convert_bytes' not found in the library");
        }
        convert_h.SYMBOL_LOOKUP = lookup;
    }


    /**
     * Convert an XER encoded MessageFrame to UPER
     * @param xer The XER encoded MessageFrame
     * @return Byte array with the UPER encoding
     */
    public byte[] xerToUper(String xer) {
        log.debug("xerToUper: {}", xer);
        try (var arena = Arena.ofConfined()) {
            MemorySegment inputBuffer = arena.allocate(textBufferSize);
            MemorySegment outputBuffer = arena.allocate(uperBufferSize);
            return convert(arena, xer.getBytes(StandardCharsets.UTF_8), "xer",
                "uper", inputBuffer, outputBuffer, uperBufferSize);
        } catch (Exception e) {
            log.error(e.getMessage(), e);
            throw new RuntimeException(e);
        }
    }

    /**
     * Convert an UPER encoded MessageFrame to XER
     * @param uper The UPER encoded MessageFrame
     * @return XER encoded result
     */
    public String uperToXer(byte[] uper) {
        log.trace("Received {} bytes", uper.length);
        try (var arena = Arena.ofConfined()) {
            MemorySegment inputBuffer = arena.allocate(uperBufferSize);
            MemorySegment outputBuffer = arena.allocate(textBufferSize);
            byte[] xerBytes = convert(arena, uper, "uper", "xer",
                inputBuffer, outputBuffer, textBufferSize);
            return new String(xerBytes, StandardCharsets.UTF_8);
        }
    }


    private byte[] convert(Arena arena, final byte[] bytes,
        final String fromEncoding, final String toEncoding, MemorySegment inputBuffer,
        MemorySegment outputBuffer, long outputBufferSize) {
        log.debug("convert: {} {}", fromEncoding, toEncoding);
        byte[] outputArray = null;

        MemorySegment heapBytes = MemorySegment.ofArray(bytes);
        inputBuffer.copyFrom(heapBytes);
        MemorySegment pduName = arena.allocateFrom(PDU, StandardCharsets.UTF_8);
        MemorySegment fromEncodingSeg = arena.allocateFrom(fromEncoding,
            StandardCharsets.UTF_8);
        MemorySegment toEncodingSeg = arena.allocateFrom(toEncoding, StandardCharsets.UTF_8);
        log.debug("calling convert_bytes");
        long numOut = 0;
        try {
            numOut = convert_bytes(pduName, fromEncodingSeg, toEncodingSeg, inputBuffer,
                bytes.length, outputBuffer, outputBufferSize);
        } catch (Throwable ex) {
            log.info("error converting");
            throw ex;
        }
        log.debug("numOut: {}", numOut);
        outputArray = new byte[(int) numOut];
        MemorySegment heapOutput = MemorySegment.ofArray(outputArray);
        MemorySegment.copy(outputBuffer, 0, heapOutput, 0, numOut);

        return outputArray;
    }

}
